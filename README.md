Simple Chat Server

一个基于 Java 构建的简易分布式即时通讯系统（学习项目）。

通过从零开始构建一个聊天系统，巩固 Java 面向对象编程思想，学习了解：
- Java 面向对象建模
- Maven 项目管理和依赖管理
- SLF4J & Logback 日志框架
- Socket 网络编程
- 多线程并发处理
- 序列化与通信协议设计
- ...（后续持续更新）

- **语言**: Java 23
- **构建工具**: Apache Maven
- **日志框架**: SLF4J + Logback
- **JSON 序列化**: Gson
- **网络通信**: Java Socket API

## 📝 学习日志

### Day 1: 项目奠基与模型设计
- ✅ 成功搭建 Maven 项目环境并解决路径与编码问题
- ✅ 引入 SLF4J + Logback 日志框架，替代 `System.out.println`
- ✅ 采用 OOP 思想进行领域建模，创建了 `User`（用户）和 `Message`（消息）两个核心实体类
- ✅ 实践了封装、构造方法、Getter/Setter 和 `toString()` 方法
- ✅ 在主程序中完成了对象的实例化、关联与日志输出

### Day 2: 网络通信基础
- ✅ 实现基于 TCP Socket 的单线程阻塞式客户端-服务器模型
- ✅ 创建 `Server` 类，使用 `ServerSocket` 在指定端口监听
- ✅ 创建 `Client` 类，使用 `Socket` 主动连接服务器
- ✅ 成功验证客户端与服务器的三次握手连接建立
- ✅ 学习并使用 `try-with-resources` 语法自动管理资源，避免连接泄漏

### Day 3: 多线程并发处理
- ✅ 深入理解 `Runnable` 任务与 `Thread` 执行线程分离的并发模型
- ✅ 使用 `ExecutorService` 线程池管理服务器线程资源
- ✅ 成功将单线程服务器改造为多线程模型，支持并发处理多个客户端连接
- ✅ 通过线程池日志 (`[pool-1-thread-X]`) 验证了多线程并发执行的效果
- ✅ 探讨了 `Executors` 工厂方法与 `ThreadPoolExecutor` 构造函数的区别与选用场景

### Day 4: 消息协议与双向通信
- ✅ 设计并实现了基于 JSON 的应用层通信协议
- ✅ 引入 Gson 库实现 Java 对象与 JSON 字符串的序列化/反序列化
- ✅ 创建 `NetworkUtils` 工具类封装消息发送/接收逻辑，提高代码复用性
- ✅ 实现客户端与服务器的双向实时消息交互
- ✅ 使用多线程实现客户端消息接收与发送的并行处理
- ✅ 完善程序退出机制，实现优雅的客户端断开连接

### Day 5: 群聊广播与状态管理
- ✅ **深入理解并发安全**：掌握了 `ConcurrentHashMap` 的分段锁机制与 `CopyOnWriteArrayList` 的写时复制原理及其适用场景。
- ✅ **实现广播机制**：成功改造服务器，可将任一客户端的消息实时广播给所有其他在线用户。
- ✅ **在线用户管理**：使用 `ConcurrentHashMap<Socket, User>` 高效、安全地管理在线客户端状态。
- ✅ **系统消息通知**：实现用户加入、离开聊天室的系统级广播通知。
- ✅ **设计通信协议**：确立了连接建立后的"登录握手"协议，客户端需首先声明自身身份。
- ✅ **架构设计实践**：清晰划分了客户端与服务器的职责（客户端发送应用数据，服务器管理全局状态）。

## 🎯 后续计划

## 🎯 后续计划

- [x] **Day 5**: 实现广播功能，使一个客户端的消息可以发送给所有其他在线客户端
- [ ] **Day 6**: 实现私聊功能，支持 `@username message` 格式的指定用户点对点消息传输
- [ ] **Day 7**: 实现用户登录与注册功能，由客户端输入用户名，服务器端维护用户列表
- [ ] **Day 8**: 实现聊天命令系统，支持如 `/list`（查看在线用户）、`/help`（查看帮助）等命令
- [ ] **Day 9**: 数据持久化，将用户信息与聊天记录保存至数据库
- [ ] ...（持续更新）
